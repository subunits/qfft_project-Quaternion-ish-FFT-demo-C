// qfft.c
// Demo project: pack RGB into a "quaternion-like" structure and compute per-channel 2D transforms.
// - Provides a naive 2D DFT implementation (always available)
// - Optionally compiles with FFTW3 (if -DWITH_FFTW and linked with -lfftw3 -lm)
// Usage:
//   Build (naive DFT only):
//     make
//   Build with FFTW (if FFTW3 available on your system):
//     make WITH_FFTW=1
//   Run:
//     ./qfft input.ppm out_prefix
//
// Outputs:
//   out_prefix_R.pgm, out_prefix_G.pgm, out_prefix_B.pgm  (magnitude images, P5 PGM)
//
// Notes:
//  - For large images the naive DFT is very slow. Use FFTW-enabled build for practical speed.
//  - This program keeps the "scalar" (real) quaternion part zero and packs RGB into imaginary parts.
//
// Author: Generated by ChatGPT (GPT-5 Thinking mini) for user
// License: MIT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef unsigned char uchar;

static void die(const char *msg) {
    fprintf(stderr, "%s\n", msg);
    exit(1);
}

typedef struct {
    int w, h;
    uchar *data; // RGBRGB...
} Image;

// Simple P6 PPM reader (minimal)
Image *read_ppm(const char *filename) {
    FILE *f = fopen(filename, "rb");
    if(!f) die("Failed to open input file.");

    char magic[3]={0};
    if(!fgets(magic, sizeof(magic), f)) die("Failed to read magic.");
    if(strncmp(magic, "P6", 2) != 0) die("Not a P6 PPM file.");

    // Skip comments and read width height maxval
    int w=0,h=0,mv=0;
    while(w==0 || h==0 || mv==0) {
        int c = fgetc(f);
        if(c== '#') { // comment line
            while((c = fgetc(f)) != '\n' && c != EOF);
            continue;
        }
        ungetc(c, f);
        if(fscanf(f, "%d %d %d", &w, &h, &mv) != 3) die("Failed to parse header.");
    }
    if(mv != 255) die("Only maxval 255 supported.");
    // consume single whitespace after header
    int c = fgetc(f);
    (void)c;

    size_t pix = (size_t)w * h;
    uchar *data = malloc(pix * 3);
    if(!data) die("Out of memory.");
    size_t read = fread(data, 3, pix, f);
    if(read != pix) {
        free(data);
        die("Failed to read pixel data.");
    }
    fclose(f);

    Image *img = malloc(sizeof(Image));
    img->w = w; img->h = h; img->data = data;
    return img;
}

static void write_pgm(const char *filename, int w, int h, const double *vals) {
    // Normalize to 0..255 (log scaling recommended for DFT magnitudes -> do simple log(1+v))
    double maxv = 0.0;
    for(int i=0;i<w*h;i++) if(vals[i] > maxv) maxv = vals[i];
    FILE *f = fopen(filename, "wb");
    if(!f) die("Failed to open output file.");
    fprintf(f, "P5\n%d %d\n255\n", w, h);
    for(int i=0;i<w*h;i++) {
        double v = vals[i];
        // apply log scaling to reveal low-magnitude content
        double s = log(1.0 + v);
        double scaled;
        if(maxv > 0) scaled = s / log(1.0 + maxv);
        else scaled = 0.0;
        int iv = (int)round(255.0 * scaled);
        if(iv < 0) iv = 0;
        if(iv > 255) iv = 255;
        fputc((uchar)iv, f);
    }
    fclose(f);
}

// Naive 2D DFT for single real-valued image channel
static void dft2d_magnitude_naive(const double *in, int w, int h, double *mag) {
    const double TWO_PI = 2.0 * M_PI;
    for(int v=0; v<h; v++) {
        for(int u=0; u<w; u++) {
            double re = 0.0;
            double im = 0.0;
            for(int y=0; y<h; y++) {
                for(int x=0; x<w; x++) {
                    double val = in[y*w + x];
                    double phase = TWO_PI * ((double)u * x / w + (double)v * y / h);
                    double c = cos(-phase);
                    double s = sin(-phase);
                    re += val * c;
                    im += val * s;
                }
            }
            double magnitude = sqrt(re*re + im*im);
            mag[v*w + u] = magnitude;
        }
    }
}

#ifdef WITH_FFTW
// FFTW-based separable 2D FFT magnitude for real input -> uses complex outputs per row/col
#include <fftw3.h>
static void fftw2d_magnitude_real(const double *in, int w, int h, double *mag) {
    // Perform 2D FFT using fftw (real->complex for rows then cols or use r2c/c2r).
    // We'll do a straightforward approach: create complex array and run 2D complex FFT.
    int N = w*h;
    fftw_complex *data = fftw_malloc(sizeof(fftw_complex) * N);
    if(!data) die("fftw_malloc failed");
    // initialize complex input (real part = input, imag = 0)
    for(int i=0;i<N;i++){ data[i][0] = in[i]; data[i][1] = 0.0; }
    fftw_plan plan = fftw_plan_dft_2d(h, w, data, data, FFTW_FORWARD, FFTW_ESTIMATE);
    fftw_execute(plan);
    // compute magnitude
    for(int i=0;i<N;i++){
        double re = data[i][0], im = data[i][1];
        mag[i] = sqrt(re*re + im*im);
    }
    fftw_destroy_plan(plan);
    fftw_free(data);
}
#endif

int main(int argc, char **argv) {
    if(argc != 3) {
        fprintf(stderr, "Usage: %s input.ppm out_prefix\n", argv[0]);
        return 1;
    }
    const char *infile = argv[1];
    const char *prefix = argv[2];

    Image *img = read_ppm(infile);
    int w = img->w, h = img->h;
    size_t npix = (size_t)w * h;

    double *R = calloc(npix, sizeof(double));
    double *G = calloc(npix, sizeof(double));
    double *B = calloc(npix, sizeof(double));
    if(!R||!G||!B) die("Out of memory.");

    for(size_t i=0;i<npix;i++) {
        R[i] = img->data[3*i + 0];
        G[i] = img->data[3*i + 1];
        B[i] = img->data[3*i + 2];
    }

    double *magR = calloc(npix, sizeof(double));
    double *magG = calloc(npix, sizeof(double));
    double *magB = calloc(npix, sizeof(double));
    if(!magR||!magG||!magB) die("Out of memory.");

#ifdef WITH_FFTW
    fprintf(stderr, "Computing 2D FFT via FFTW for %d x %d image...\n", w, h);
    fftw2d_magnitude_real(R,w,h,magR);
    fftw2d_magnitude_real(G,w,h,magG);
    fftw2d_magnitude_real(B,w,h,magB);
#else
    fprintf(stderr, "Computing naive 2D DFT for %d x %d image (this is O(N^4) and may be slow)...\n", w, h);
    dft2d_magnitude_naive(R, w, h, magR);
    dft2d_magnitude_naive(G, w, h, magG);
    dft2d_magnitude_naive(B, w, h, magB);
#endif

    char path[1024];
    snprintf(path, sizeof(path), "%s_R.pgm", prefix);
    write_pgm(path, w, h, magR);
    snprintf(path, sizeof(path), "%s_G.pgm", prefix);
    write_pgm(path, w, h, magG);
    snprintf(path, sizeof(path), "%s_B.pgm", prefix);
    write_pgm(path, w, h, magB);

    fprintf(stderr, "Wrote %s_R.pgm, %s_G.pgm, %s_B.pgm\n", prefix, prefix, prefix);

    free(R); free(G); free(B);
    free(magR); free(magG); free(magB);
    free(img->data); free(img);
    return 0;
}
